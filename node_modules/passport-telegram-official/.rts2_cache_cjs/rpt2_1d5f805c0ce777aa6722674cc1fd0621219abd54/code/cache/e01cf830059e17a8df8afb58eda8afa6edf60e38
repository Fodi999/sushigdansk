{"code":"import { Strategy } from 'passport-strategy';\r\nimport { assign } from 'lodash';\r\nimport * as crypto from 'crypto';\r\nimport deferPromise from './deferPromise';\r\nexport const defaultOptions = {\r\n    queryExpiration: 86400,\r\n    passReqToCallback: false,\r\n};\r\n/**\r\n * `TelegramStrategy` constructor.\r\n *\r\n * The Telegram authentication strategy authenticates requests by delegating to\r\n * Telegram using their protocol: https://core.telegram.org/widgets/login\r\n *\r\n * Applications must supply a `verify` callback which accepts an `account` object,\r\n * and then calls `done` callback sypplying a `user`, which should be set to `false` if the\r\n * credentials are not valid.  If an exception occurred, `error` should be set.\r\n *\r\n * More info here: https://core.telegram.org/widgets/login\r\n *\r\n * @param {Object} options\r\n * @param {Function} verify\r\n * @example\r\n * passport.use(new TelegramStrategy({\r\n *   botId: 12434151\r\n * }), (user) => {\r\n *   User.findOrCreate({telegramId: user.id}, done);\r\n * });\r\n */\r\nexport default class TelegramStrategy extends Strategy {\r\n    constructor(options, verify) {\r\n        super();\r\n        if (!options.botToken) {\r\n            throw new TypeError('options.botToken is required in TelegramStrategy');\r\n        }\r\n        if (!verify) {\r\n            throw new TypeError('LocalStrategy requires a verify callback');\r\n        }\r\n        this.options = assign({}, defaultOptions, options);\r\n        this.name = 'telegram';\r\n        this.verify = verify;\r\n        this.hashedBotToken = this.botToken();\r\n    }\r\n    authenticate(req, options) {\r\n        const query = req.method === 'GET' ? req.query : req.body;\r\n        try {\r\n            const validationResult = this.validateQuery(req);\r\n            if (validationResult !== true)\r\n                return validationResult;\r\n            const promise = deferPromise();\r\n            if (this.options.passReqToCallback) {\r\n                this.verify(req, query, promise.callback);\r\n            }\r\n            else {\r\n                this.verify(query, promise.callback);\r\n            }\r\n            promise.then(([user, info]) => {\r\n                if (!user)\r\n                    return this.fail(info);\r\n                this.success(user, info);\r\n            }).catch((err) => {\r\n                return this.error(err);\r\n            });\r\n        }\r\n        catch (e) {\r\n            return this.error(e);\r\n        }\r\n    }\r\n    /**\r\n     * Function to check if provided date in callback is outdated\r\n     * @returns {number}\r\n     */\r\n    getTimestamp() {\r\n        return parseInt((+new Date / 1000), 10);\r\n    }\r\n    // We have to hash botToken too\r\n    botToken() {\r\n        // Use buffer to better performance\r\n        return crypto.createHash('sha256').update(this.options.botToken).digest();\r\n    }\r\n    /**\r\n     * Used to validate if fields like telegram must send are exists\r\n     * @param {e.Request} req\r\n     * @returns {any}\r\n     */\r\n    validateQuery(req) {\r\n        const query = req.method === 'GET' ? req.query : req.body;\r\n        if (!query.auth_date || !query.hash || !query.id) {\r\n            return this.fail({ message: 'Missing some important data' }, 400);\r\n        }\r\n        const authDate = parseInt(query.auth_date);\r\n        if (this.options.queryExpiration !== -1 &&\r\n            (isNaN(authDate) || this.getTimestamp() - authDate > this.options.queryExpiration)) {\r\n            return this.fail({ message: 'Data is outdated' }, 400);\r\n        }\r\n        const sorted = Object.keys(query).sort();\r\n        const mapped = sorted // Everything except hash must be mapped\r\n            .filter(d => d !== 'hash')\r\n            .map(key => `${key}=${query[key]}`);\r\n        const hashString = mapped.join('\\n');\r\n        const hash = crypto\r\n            .createHmac('sha256', this.hashedBotToken)\r\n            .update(hashString)\r\n            .digest('hex');\r\n        if (hash !== query.hash)\r\n            return this.fail({ message: 'Hash validation failed' }, 403);\r\n        return true;\r\n    }\r\n}\r\n//# sourceMappingURL=strategy.js.map","map":"{\"version\":3,\"file\":\"strategy.js\",\"sourceRoot\":\"\",\"sources\":[\"../../src/strategy.ts\"],\"names\":[],\"mappings\":\"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\"}","dts":{"name":"/Users/andrey/temp/passport-telegram-official/strategy.d.ts","writeByteOrderMark":false,"text":"/// <reference types=\"node\" />\r\nimport { Strategy } from 'passport-strategy';\r\nimport * as express from 'express';\r\nexport declare type TelegramOptions = {\r\n    botToken: string;\r\n    queryExpiration?: number;\r\n    passReqToCallback?: boolean;\r\n};\r\nexport declare type TelegramUser = {\r\n    auth_date: number;\r\n    first_name: string;\r\n    hash: string;\r\n    id: number;\r\n    last_name: string;\r\n    username: string;\r\n};\r\nexport declare type DoneCallback = (err: any, user: any, info: any) => void;\r\nexport declare type CallbackWithRequest = (req: express.Request, user: TelegramUser, done: DoneCallback) => void;\r\nexport declare type CallbackWithoutRequest = (user: TelegramUser, done: DoneCallback) => void;\r\nexport declare type VerifyCallback = CallbackWithRequest | CallbackWithoutRequest;\r\nexport declare const defaultOptions: {\r\n    queryExpiration: number;\r\n    passReqToCallback: boolean;\r\n};\r\n/**\r\n * `TelegramStrategy` constructor.\r\n *\r\n * The Telegram authentication strategy authenticates requests by delegating to\r\n * Telegram using their protocol: https://core.telegram.org/widgets/login\r\n *\r\n * Applications must supply a `verify` callback which accepts an `account` object,\r\n * and then calls `done` callback sypplying a `user`, which should be set to `false` if the\r\n * credentials are not valid.  If an exception occurred, `error` should be set.\r\n *\r\n * More info here: https://core.telegram.org/widgets/login\r\n *\r\n * @param {Object} options\r\n * @param {Function} verify\r\n * @example\r\n * passport.use(new TelegramStrategy({\r\n *   botId: 12434151\r\n * }), (user) => {\r\n *   User.findOrCreate({telegramId: user.id}, done);\r\n * });\r\n */\r\nexport default class TelegramStrategy extends Strategy {\r\n    name: string;\r\n    options: TelegramOptions;\r\n    verify: any;\r\n    hashedBotToken: Buffer;\r\n    constructor(options: TelegramOptions, verify: VerifyCallback);\r\n    authenticate(req: express.Request, options?: any): false | void;\r\n    /**\r\n     * Function to check if provided date in callback is outdated\r\n     * @returns {number}\r\n     */\r\n    getTimestamp(): number;\r\n    botToken(): Buffer;\r\n    /**\r\n     * Used to validate if fields like telegram must send are exists\r\n     * @param {e.Request} req\r\n     * @returns {any}\r\n     */\r\n    validateQuery(req: express.Request): boolean | void;\r\n}\r\n"}}
