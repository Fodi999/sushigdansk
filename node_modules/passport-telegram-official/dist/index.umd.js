(function (global, factory) {
	typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports, require('lodash'), require('crypto')) :
	typeof define === 'function' && define.amd ? define(['exports', 'lodash', 'crypto'], factory) :
	(factory((global.passportTelegramOfficial = {}),global.lodash,global.crypto));
}(this, (function (exports,lodash,crypto) {
	function createCommonjsModule(fn, module) {
		return module = { exports: {} }, fn(module, module.exports), module.exports;
	}

	/**
	 * Creates an instance of `Strategy`.
	 *
	 * @constructor
	 * @api public
	 */
	function Strategy() {
	}

	/**
	 * Authenticate request.
	 *
	 * This function must be overridden by subclasses.  In abstract form, it always
	 * throws an exception.
	 *
	 * @param {Object} req The request to authenticate.
	 * @param {Object} [options] Strategy-specific options.
	 * @api public
	 */
	Strategy.prototype.authenticate = function(req, options) {
	  throw new Error('Strategy#authenticate must be overridden by subclass');
	};


	/**
	 * Expose `Strategy`.
	 */
	var strategy = Strategy;

	var lib = createCommonjsModule(function (module, exports) {
	/**
	 * Module dependencies.
	 */



	/**
	 * Expose `Strategy` directly from package.
	 */
	exports = module.exports = strategy;

	/**
	 * Export constructors.
	 */
	exports.Strategy = strategy;
	});
	var lib_1 = lib.Strategy;

	function deferPromise() {
	  var Promise = global.Promise;
	  var resolve, reject;
	  var promise = new Promise(function (_resolve, _reject) {
	    resolve = _resolve;
	    reject = _reject;
	  });
	  return {
	    then: function (f) { return promise.then(f); },
	    callback: function (err) {
	      var data = [], len = arguments.length - 1;
	      while ( len-- > 0 ) data[ len ] = arguments[ len + 1 ];

	      return err ? reject(err) : resolve(data);
	  },
	    promise: promise
	  };
	}

	var defaultOptions = {
	  queryExpiration: 86400,
	  passReqToCallback: false
	};
	/**
	 * `TelegramStrategy` constructor.
	 *
	 * The Telegram authentication strategy authenticates requests by delegating to
	 * Telegram using their protocol: https://core.telegram.org/widgets/login
	 *
	 * Applications must supply a `verify` callback which accepts an `account` object,
	 * and then calls `done` callback sypplying a `user`, which should be set to `false` if the
	 * credentials are not valid.  If an exception occurred, `error` should be set.
	 *
	 * More info here: https://core.telegram.org/widgets/login
	 *
	 * @param {Object} options
	 * @param {Function} verify
	 * @example
	 * passport.use(new TelegramStrategy({
	 *   botId: 12434151
	 * }), (user) => {
	 *   User.findOrCreate({telegramId: user.id}, done);
	 * });
	 */

	var TelegramStrategy = /*@__PURE__*/(function (Strategy) {
	  function TelegramStrategy(options, verify) {
	    Strategy.call(this);

	    if (!options.botToken) {
	      throw new TypeError('options.botToken is required in TelegramStrategy');
	    }

	    if (!verify) {
	      throw new TypeError('LocalStrategy requires a verify callback');
	    }

	    this.options = lodash.assign({}, defaultOptions, options);
	    this.name = 'telegram';
	    this.verify = verify;
	    this.hashedBotToken = this.botToken();
	  }

	  if ( Strategy ) TelegramStrategy.__proto__ = Strategy;
	  TelegramStrategy.prototype = Object.create( Strategy && Strategy.prototype );
	  TelegramStrategy.prototype.constructor = TelegramStrategy;

	  TelegramStrategy.prototype.authenticate = function authenticate (req, options) {
	    var this$1 = this;

	    var query = req.method === 'GET' ? req.query : req.body;

	    try {
	      var validationResult = this.validateQuery(req);
	      if (validationResult !== true) { return validationResult; }
	      var promise = deferPromise();

	      if (this.options.passReqToCallback) {
	        this.verify(req, query, promise.callback);
	      } else {
	        this.verify(query, promise.callback);
	      }

	      promise.then(function (ref) {
	        var user = ref[0];
	        var info = ref[1];

	        if (!user) { return this$1.fail(info); }
	        this$1.success(user, info);
	      }).catch(function (err) {
	        return this$1.error(err);
	      });
	    } catch (e) {
	      return this.error(e);
	    }
	  };
	  /**
	   * Function to check if provided date in callback is outdated
	   * @returns {number}
	   */


	  TelegramStrategy.prototype.getTimestamp = function getTimestamp () {
	    return parseInt(+new Date() / 1000, 10);
	  }; // We have to hash botToken too


	  TelegramStrategy.prototype.botToken = function botToken () {
	    // Use buffer to better performance
	    return crypto.createHash('sha256').update(this.options.botToken).digest();
	  };
	  /**
	   * Used to validate if fields like telegram must send are exists
	   * @param {e.Request} req
	   * @returns {any}
	   */


	  TelegramStrategy.prototype.validateQuery = function validateQuery (req) {
	    var query = req.method === 'GET' ? req.query : req.body;

	    if (!query.auth_date || !query.hash || !query.id) {
	      return this.fail({
	        message: 'Missing some important data'
	      }, 400);
	    }

	    var authDate = parseInt(query.auth_date);

	    if (this.options.queryExpiration !== -1 && (isNaN(authDate) || this.getTimestamp() - authDate > this.options.queryExpiration)) {
	      return this.fail({
	        message: 'Data is outdated'
	      }, 400);
	    }

	    var sorted = Object.keys(query).sort();
	    var mapped = sorted // Everything except hash must be mapped
	    .filter(function (d) { return d !== 'hash'; }).map(function (key) { return (key + "=" + (query[key])); });
	    var hashString = mapped.join('\n');
	    var hash = crypto.createHmac('sha256', this.hashedBotToken).update(hashString).digest('hex');
	    if (hash !== query.hash) { return this.fail({
	      message: 'Hash validation failed'
	    }, 403); }
	    return true;
	  };

	  return TelegramStrategy;
	}(lib_1));

	exports.TelegramStrategy = TelegramStrategy;
	exports.default = TelegramStrategy;

})));
//# sourceMappingURL=index.umd.js.map
