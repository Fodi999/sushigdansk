{"version":3,"file":"index.js","sources":["../node_modules/passport-strategy/lib/strategy.js","../node_modules/passport-strategy/lib/index.js","../src/deferPromise.ts","../src/strategy.ts"],"sourcesContent":["/**\n * Creates an instance of `Strategy`.\n *\n * @constructor\n * @api public\n */\nfunction Strategy() {\n}\n\n/**\n * Authenticate request.\n *\n * This function must be overridden by subclasses.  In abstract form, it always\n * throws an exception.\n *\n * @param {Object} req The request to authenticate.\n * @param {Object} [options] Strategy-specific options.\n * @api public\n */\nStrategy.prototype.authenticate = function(req, options) {\n  throw new Error('Strategy#authenticate must be overridden by subclass');\n};\n\n\n/**\n * Expose `Strategy`.\n */\nmodule.exports = Strategy;\n","/**\n * Module dependencies.\n */\nvar Strategy = require('./strategy');\n\n\n/**\n * Expose `Strategy` directly from package.\n */\nexports = module.exports = Strategy;\n\n/**\n * Export constructors.\n */\nexports.Strategy = Strategy;\n","export default function deferPromise() {\n  const Promise = global.Promise as any;\n  let resolve, reject;\n  const promise = new Promise((_resolve, _reject) => {\n    resolve = _resolve;\n    reject = _reject;\n  });\n\n  return {\n    then: f => promise.then(f),\n    callback: (err, ...data) => err ? reject(err) : resolve(data),\n    promise\n  };\n}\n","import { Strategy } from 'passport-strategy';\nimport { assign } from 'lodash';\nimport * as express from 'express';\nimport * as crypto from 'crypto';\nimport deferPromise from './deferPromise';\n\nexport type TelegramOptions = {\n  // An unique token which you can get from @BotFather\n  botToken: string;\n  // Max seconds expiration. Default is 86400\n  queryExpiration?: number;\n  // Should pass express req as first argument if true\n  passReqToCallback?: boolean\n}\n\n// Typical query received to redirectUrl\nexport type TelegramUser = {\n  auth_date: number;\n  first_name: string;\n  hash: string\n  id: number;\n  last_name: string;\n  username: string;\n}\n\nexport type DoneCallback = (err: any, user: any, info: any) => void;\n\nexport type CallbackWithRequest = (req: express.Request, user: TelegramUser, done: DoneCallback) => void;\nexport type CallbackWithoutRequest = (user: TelegramUser, done: DoneCallback) => void;\n\nexport type VerifyCallback = CallbackWithRequest | CallbackWithoutRequest;\n\nexport const defaultOptions = {\n  queryExpiration: 86400,\n  passReqToCallback: false,\n};\n\n/**\n * `TelegramStrategy` constructor.\n *\n * The Telegram authentication strategy authenticates requests by delegating to\n * Telegram using their protocol: https://core.telegram.org/widgets/login\n *\n * Applications must supply a `verify` callback which accepts an `account` object,\n * and then calls `done` callback sypplying a `user`, which should be set to `false` if the\n * credentials are not valid.  If an exception occurred, `error` should be set.\n *\n * More info here: https://core.telegram.org/widgets/login\n *\n * @param {Object} options\n * @param {Function} verify\n * @example\n * passport.use(new TelegramStrategy({\n *   botId: 12434151\n * }), (user) => {\n *   User.findOrCreate({telegramId: user.id}, done);\n * });\n */\nexport default class TelegramStrategy extends Strategy {\n  name: string;\n  options: TelegramOptions;\n  verify;\n  hashedBotToken: Buffer;\n\n  constructor(options: TelegramOptions, verify: VerifyCallback) {\n    super();\n\n    if (!options.botToken) {\n      throw new TypeError('options.botToken is required in TelegramStrategy');\n    }\n    if (!verify) {\n      throw new TypeError('LocalStrategy requires a verify callback');\n    }\n\n    this.options = assign({}, defaultOptions, options);\n    this.name = 'telegram';\n    this.verify = verify;\n    this.hashedBotToken = this.botToken();\n  }\n\n  authenticate(req: express.Request, options?: any) {\n    const query = req.method === 'GET' ? req.query : req.body;\n\n    try {\n      const validationResult = this.validateQuery(req);\n      if (validationResult !== true) return validationResult;\n\n      const promise = deferPromise();\n\n      if (this.options.passReqToCallback) {\n        this.verify(req, query, promise.callback);\n      } else {\n        this.verify(query, promise.callback);\n      }\n\n      promise.then(([user, info]) => {\n        if (!user) return this.fail(info);\n        this.success(user, info);\n      }).catch((err) => {\n        return this.error(err);\n      });\n    } catch (e) {\n      return this.error(e);\n    }\n  }\n\n  /**\n   * Function to check if provided date in callback is outdated\n   * @returns {number}\n   */\n  getTimestamp() {\n    return parseInt((+new Date / 1000) as any, 10);\n  }\n\n  // We have to hash botToken too\n  botToken() {\n    // Use buffer to better performance\n    return crypto.createHash('sha256').update(this.options.botToken).digest();\n  }\n\n  /**\n   * Used to validate if fields like telegram must send are exists\n   * @param {e.Request} req\n   * @returns {any}\n   */\n  validateQuery(req: express.Request): boolean | void {\n    const query = req.method === 'GET' ? req.query : req.body;\n\n    if (!query.auth_date || !query.hash || !query.id) {\n      return this.fail({ message: 'Missing some important data' }, 400);\n    }\n\n    const authDate = parseInt(query.auth_date);\n    if (this.options.queryExpiration !== -1 &&\n     (isNaN(authDate) || this.getTimestamp() - authDate > this.options.queryExpiration)\n    ) {\n      return this.fail({ message: 'Data is outdated' }, 400);\n    }\n\n    const sorted = Object.keys(query).sort();\n    const mapped = sorted // Everything except hash must be mapped\n     .filter(d => d !== 'hash')\n     .map(key => `${key}=${query[key]}`);\n\n    const hashString = mapped.join('\\n');\n    const hash = crypto\n     .createHmac('sha256', this.hashedBotToken)\n     .update(hashString)\n     .digest('hex');\n\n    if (hash !== query.hash) return this.fail({ message: 'Hash validation failed' }, 403);\n\n    return true;\n  }\n}"],"names":["Strategy","deferPromise","Promise","global","resolve","reject","promise","_resolve","_reject","then","f","callback","err","data","const","defaultOptions","queryExpiration","passReqToCallback","TelegramStrategy","constructor","options","verify","botToken","TypeError","assign","name","hashedBotToken","authenticate","req","query","method","body","validationResult","validateQuery","info","user","this","fail","success","catch","error","e","getTimestamp","parseInt","Date","crypto","update","digest","auth_date","hash","id","message","authDate","isNaN","sorted","Object","keys","sort","mapped","filter","d","map","key","hashString","join"],"mappings":"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"}